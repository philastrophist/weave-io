{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"weaveio","text":"<p>This is documentation for the use, maintenance, and development of <code>weaveio</code>, the data product database tool in use by the WEAVE-LOFAR survey.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>The purpose of <code>weaveio</code> is to facilitate easy querying of complex data spread over multiple file types. </p> <p>Specifically, it was designed to allow the user write complex queries over the L1 and L2 data structures output by the WEAVE CPS and APS.  The data consists of weather measurements, spectra (both 1D and 2D), previous survey input target observations, redshifts, emission lines, velocity dispersion etc.</p> <p>All of this information is highly hierarchical. I.e. a spectrum requires a target, which has an {ra,dec} coordinate.  The spectrum also has numerous emission line fits and redshifts which have been inferred from the spectrum. You could write this as <code>(target {ra, dec})--&gt;(spectrum)--&gt;(fit {redshift})--&gt;(emission_line)</code>.  This kind of structure lends itself to be written in an object orientated way and queried as such.</p> <p>Essentially, all of <code>weaveio</code> is designed to turn this:</p> <pre><code>from astropy.io import fits\nfrom astropy.table import Table\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\ntarget_name = 'xxxxx'\nexposure_mjd = 57639\nwvl = []\nflux = []\nfor file in os.listdir('opr3'):\nif 'single' in file:\nhdus = fits.open(file)\nif floor(hdus[0].header['MJD']) == exposure_mjd:\nt = Table(hdus['FIBTABLE'].data)\nfilt = t['TARGNAME'] == target_name\nif sum(filt):\nheader = hdulist[1].header\nincrement, zeropoint = header['cd1_1'], header['crval1'] \nsize = header['naxis1']\nwvl.append(np.arange(0, size) * increment) + zeropoint)\nflux.append(hdulist[1].data[filt])\nplt.plot(wvl, flux)\nplt.title('All L1 single spectra of {target_name} on day {exposure_mjd}')\n</code></pre> <p>Into this:</p> <pre><code>import matplotlib.pyplot as plt\nfrom weaveio import *\ndb = Data('opr3')\nspectra = db.survey_targets[target_name].l1single_spectra\nresult = spectra[floor(spectra.exposure.mjd) == exposure_mjd][['wvl', 'flux']]()\nplt.plot(result.wvl, result.flux)\nplt.title('All L1 single spectra of {target_name} on day {exposure_mjd}')         \n</code></pre>"},{"location":"building-queries/","title":"Identifying, filtering and aggregating","text":""},{"location":"building-queries/#finding-objects-by-their-unique-identifiers","title":"Finding objects by their unique identifiers","text":"<p>If an object defines an idname in its class definition, you can find it in a query by using square brackets:</p> <p><pre><code>data.obs[2345]\n</code></pre> This will return a query pointed at a single ob from which you can continue the query:</p> <pre><code>data.obs[2345].l1single_spectra...\n</code></pre> <p>You can also access more than one object by listing them in the square brackets:</p> <pre><code>data.obs[2345, 3443, ...]\n</code></pre> <p>Failure</p> <p>You can only filter by id if the object is uniquely defined (i.e. specifies an <code>idname</code> in its definition). <pre><code>&gt;&gt;&gt; data.l1single_spectra[0]\nValueError: L1SingleSpectrum is not globally uniquely defined\n</code></pre></p> <p>Warning</p> <p>Cardinality still applies when filtering by id! <pre><code>&gt;&gt;&gt; all_spectra = data.l1single_spectra\n&gt;&gt;&gt; an_ob = all_spectra.obs[1234]\n&gt;&gt;&gt; an_ob.id()\n[1234, 1234, 1234, 1234, 1234, 1234, ...]\n&gt;&gt;&gt; data.obs[1234].id()\n1234\n&gt;&gt;&gt; all_spectra.ob.id()\n8452  # doesnt have to be the same here \n</code></pre></p> <p>Once you've traversed to an attribute, you can filter and aggregate.</p>"},{"location":"building-queries/#filtering","title":"Filtering","text":"<p>You can reduce the cardinality of a query structure by filtering either by id as above, or by a boolean mask constructed as part of the query.</p> <p>You can create the mask by comparing either multiple queries or a query with a python value:</p>"},{"location":"building-queries/#using-a-python-value-filter-spectra-to-those-with-snr-greater-than-10","title":"Using a python value: Filter spectra to those with SNR greater than 10","text":"<pre><code>data.l1single_spectra[data.l1single_spectra.snr &gt; 10]\n</code></pre>"},{"location":"building-queries/#using-queries-filter-spectra-to-those-with-snr-greater-the-average-snr-of-all-spectra-in-the-database","title":"Using queries: Filter spectra to those with SNR greater the average SNR of all spectra in the database","text":"<pre><code>data.l1single_spectra[data.l1single_spectra.snr &gt; mean(data.l1single_spectra.snr)]\n</code></pre> <p>Failure</p> <p>You cannot filter an object by a boolean mask which does not have said object in its history. All of these will fail:  <pre><code>&gt;&gt;&gt; data.l1single_spectra[np.array([1,2,3]) &gt; 0]\nTypeError: Cannot filter a query by a non-query\n&gt;&gt;&gt; data.l1single_spectra[data.obs.mjd &lt; today()]\nCardinalityError: Cannot filter &lt;ObjectQuery L1singleSpectrum&gt; relative to &lt;ObjectQuery OB&gt; since it is not a parent.\n</code></pre></p>"},{"location":"building-queries/#aggregation","title":"Aggregation","text":"<p>A query is a chain of objects and attributes (maybe a combination of more than one chain if you've compared or performed arithmetic). You can aggregate the end of this chain structure relative to some other point in the chain. This is similar to groupby-apply in SQL except that everything is already implicitly grouped in <code>weaveio</code>. <code>weaveio</code> defines the aggregation function: <code>sum, max, min, mean, std, count, any, all, exists</code>.</p> <p>For example:</p> <p>Count the number of objects in the database:</p> <pre><code>&gt;&gt;&gt; count(data.obs)()\n30\n</code></pre> <p>Count the number of objects with respect to another:</p> <pre><code>&gt;&gt;&gt; result = count(data.obs.l1single_spectra, wrt=data.obs)()\n&gt;&gt;&gt; result\n[902, 945, 854, ...]\n&gt;&gt;&gt; len(result)  # this is the length of the python list not the count of the query\n30\n</code></pre> <p>All aggregation functions work in the same way: define a long query chain and use <code>wrt=</code> to select the point in the chain you wish to aggregate to. The resulting structure will have the same cardinality as the query given in the <code>wrt</code> argument. If <code>wrt</code> is not given, <code>weaveio</code> will assume you mean <code>wrt=database</code> and will always return a singular result.</p> <p>Failure</p> <p>You may only aggregate a query relative to a point in its history. <pre><code>&gt;&gt;&gt; count(data.obs.l1single_spectra, wrt=data.runs)\nCardinalityError: Cannot aggregate &lt;ObjectQuery OB-L1singleSpectrum&gt; relative to &lt;ObjectQuery Run&gt; since it is not a parent.\n</code></pre></p> <p>Failure</p> <p>Moreover, you can only currently do aggregate to a point that was explicitly traversed before. The chain <code>data.obs.l1single_spectra</code> implicitly goes through <code>runs</code> because each <code>L1SingleSpectrum</code> originates from one run,  which originates from one OB. However, the following fails because <code>run</code> was not mentioned explicitly in the query before: <pre><code>&gt;&gt;&gt; count(data.obs.l1single_spectra, wrt=data.obs.runs)\nCardinalityError: Cannot aggregate &lt;ObjectQuery OB-L1singleSpectrum&gt; relative to &lt;ObjectQuery OB-Run&gt; since it is not a parent.\n</code></pre></p>"},{"location":"database-connector/","title":"The database connector","text":"<p>Every query in weaveio starts with a database connector - <code>Data</code>. The <code>Data</code> class represents all the information in the database and contains the backend for connecting to it.</p> <p>When designing the database schema, you inherit from the <code>Data</code> class.  However, for convenience, when you import <code>Data</code> from weaveio, the opr3 database connector is imported, not the base <code>Data</code> class.</p> <p><code>Data</code> has the following signature: <pre><code>Data(rootdir: Union[Path, str] = None, host: str = None, port: int = None, \ndbname: str = None, password: str = None, user: str = None, verbose=False)\n</code></pre> Most of these arguments will have default values which have been specified (for example in the opr3 database connector class). However, you can override any of them if necessary and <code>user</code> and <code>password</code> are required arguments. You can also specify environment variables to avoid pushing passwords to github. These are: <pre><code>WEAVEIO_DB\nWEAVEIO_HOST\nWEAVEIO_PORT\nWEAVEIO_PASSWORD\nWEAVEIO_USER\nWEAVEIO_ROOTDIR\n</code></pre></p>"},{"location":"objects/","title":"Objects and their attributes in weaveio with cats","text":"<p>Info</p> <p>This section will talk about how to access objects and their attributes in weaveio. It will talk about schema and relationships but it will not describe how to build a schema or write data to the database. This is done in the writing section.</p> <p>An object in weaveio is a container for attributes. For example, a <code>Cat</code> object has a <code>tail_length</code> attribute.  A <code>Cat</code> object may also have an <code>Owner</code> attribute (note that the <code>Owner</code> is itself an object that has its own attributes).</p> <p>Let's suppose that the database has this structure:</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> This structure is pronounced \"An Owner has a Cat which has a Toy\".</p> <p>In weaveio you always traverse to objects from another object following these arrows.</p> <ol> <li>For each cat get its owner: <code>cat.owner</code></li> <li>For each cat's owner get its name and return them all: <code>cat.owner.name()</code></li> </ol> <p>You can read the dots as \"For each cat get its owner, for each owner get its name\".</p> <p>You cannot return an object in weaveio, only attributes of objects.</p> <p>Success</p> <pre><code>&gt;&gt;&gt; database.cats.owner['name']()\n['Andrea', 'Mike', 'Humphrey']\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; database.cats.owner()\nSyntaxError: Owner cannot be returned/identified since it doesn't define any unique idname. \nIf you want to return all singular data for Owner use ...['*']\n</code></pre>"},{"location":"objects/#attribute-access","title":"Attribute access","text":"<p>In weaveio you can access attributes using either the square brackets <code>object['attribute']</code> or the dot syntax <code>object.attribute</code>.  There is no difference between them.  The only reason that you would use <code>object['attribute']</code> over <code>object.attribute</code> is when requesting more than one attribute at once (see tables).</p> <p>Weaveio is designed such that, in the relationship hierarchy above, all linked objects/attributes are accessible.</p> <p>So <code>owner.cat.toy</code> is the same as <code>owner.toy</code>:</p> <p>Success</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; owner.cat.toy() == owner.toy()\nTrue\n</code></pre></p> <p>Furthermore, <code>owner.squeakiness</code> is the same as <code>owner.toy.squeakiness</code>:</p> <p>Success</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; owner.toy.squeakiness() == owner.squeakiness()\nTrue\n</code></pre></p> <p>However, <code>cat.bike</code> is not valid because the cat has no direct access to the bike.  You must explicitly traverse to Owner first:</p> <p>Warning</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Owner --&gt; Bike;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; cat.bike\nAmbiguousPathError\n&gt;&gt;&gt; cat.owner.bike    \n</code></pre></p>"},{"location":"objects/#a-note-on-pluralisations","title":"A note on pluralisations","text":"<p>If an object has more than one linked object then you must use the plural form of the object. </p> <p>Let's consider an altered schema where there are multiple relationships between each object type. <pre><code>graph LR\n  Owner --\"many\"--&gt; Cat;\n  Cat --\"one\"--&gt; Owner;\n  Cat --\"many\"--&gt; Toy;\n  Toy--\"one\"--&gt;Cat;</code></pre></p> <p>Success</p> <pre><code>&gt;&gt;&gt; cat.toys.name()\n['mouse', 'ribbon', 'bell']\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; cat.toy.name()\nKeyError: A Cat has more than one Toy. Use the plural \"toys\".\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; toy.cat.name()\nFelix\n</code></pre>"},{"location":"objects/#cardinalty","title":"Cardinalty","text":"<p>If we interpret the dot syntax as \"for each\" as detailed above, then this implies an increase in the number of results with each level. For example, in the above example each cat has one owner and an owner can only own one cat.  Let's now say that Mike owns both Felix and Whiskers.</p> <p>The list of owners is still the same: <pre><code>&gt;&gt;&gt; database.owners['name']()\n['Andrea', 'Mike', 'Humphrey']\n</code></pre></p> <p>But now if we ask for the owner of each cat: <pre><code>&gt;&gt;&gt; database.cats.owner['name']()\n['Andrea', 'Mike', 'Humphrey', 'Mike']\n</code></pre> We can now see that Mike appears twice.</p> <p>Warning</p> <p>Things can quickly get out of control in a large interconnected database when traversing the same relationship repeatedly:  <pre><code>&gt;&gt;&gt; database.cats.owner.cats.owner['name']()\n['Andrea', 'Mike', 'Mike', 'Humphrey', 'Mike', 'Mike']\n</code></pre> Things duplicate because we've asked for the owner of each cat and then the owner of each of those cats.</p>"},{"location":"objects/#types-of-object","title":"Types of object","text":"<p>Objects have types and you can query different types just as you would normally.  In weaveio all objects inherit from <code>Hierarchy</code>:</p> <p><pre><code>&gt;&gt;&gt; database.hierarchies['name']()\n['Andrea', 'Mike', 'Humphrey', 'Felix', 'Whiskers', 'Smudge', 'mouse', 'ribbon', 'bell']\n</code></pre> If <code>Cat</code> is defined as a type of <code>Animal</code> then <code>database.animals['name']()</code> will return all the names of all the Cats:</p> <p><pre><code>&gt;&gt;&gt; database.animals['name']()\n['Smudge', 'Felix', 'Whiskers']\n</code></pre> If Owner was defined as an animal then this query would also fetch the names of the owners too.</p>"},{"location":"objects/#attribute-manipulation","title":"Attribute manipulation","text":"<p>You may perform arithmetic on attributes of objects in the query.  All standard operators are supported: <code>&lt;, &gt;, &lt;=,&gt;=, +, -, /, *, **, &amp;, |, ~</code> and they are type sensitive.</p> <p>For example:</p> <p>Success</p> <pre><code>&gt;&gt;&gt; old_cat_filter = cat.age &gt; cat.owner.age &gt; 10\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; cat.name &gt; 10 \nTypeError: &gt; expected a number, got string\n</code></pre> <p><code>weaveio</code> comes with its own versions of common scalar functions <code>log, exp, log10, sqrt, sign, floor, ceil, isnan</code>, and aggergating functions <code>sum, any, all, mean, std, count, exists, max, min</code></p> <p>Warning</p> <p><code>weaveio</code> functions override the default python functions. i.e. <code>sum</code> is replaced by <code>weaveio.sum</code> when importing with <code>from weaveio import *</code>. <code>weaveio.sum</code> supports all the functionality of Python's <code>sum</code>when not confronted with a <code>weaveio</code> query. Otherwise, it will return another <code>weaveio</code> query. Since Python's <code>sum</code> cannot be used with <code>weaveio</code>, you are recommended to import using <code>from weaveio import *</code>.</p>"},{"location":"objects/#products","title":"Products","text":"<p><code>weaveio</code> supports accessing external data products which are not held in the database. The use case for this is if the attribute is too large and no benefit is gained by storing it in the database. For instance large numerical arrays should not be stored in database and should be marked as products when uploading.</p> <p>If an attribute is marked as a product, it cannot be manipulated like normal attributes.  All functions and operators will fail. However, you may still retrieve the data products in the same way as attributes:</p> <p>Success</p> <pre><code>&gt;&gt;&gt; database.spectra.flux()\n[np.array([...]), np.array([...]), ...]\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; snr = database.spectra.flux * sqrt(database.spectra.ivar)\nTypeError: `flux` is a product and cannot be manipulated in query, only retrieved.\n</code></pre>"},{"location":"quickstart-by-example/","title":"Quickstart by example","text":""},{"location":"quickstart-by-example/#1-i-want-to-return-the-number-of-sky-spectra-in-a-given-run-runid1002850","title":"1. I want to return the number of sky spectra in a given run (runid=1002850)","text":"<p><pre><code>from weaveio import *\ndata = Data() \nrunid = 1003453\nnsky = sum(data.runs[runid].targuses == 'S')\nprint(\"number of sky targets = {}\".format(nsky()))\n</code></pre> output: <code>number of sky targets = 100</code></p> <p>We can break this down into several steps:</p> <ol> <li><code>from weaveio import *; data = Data()</code> - Import all the necessary <code>weaveio</code> functions and start the default lofar database link (the default is opr3 but this may change in the future).</li> <li><code>data.</code> - Start building a query using data connection established above</li> <li><code>data.runs</code> - Get all runs</li> <li><code>data.runs[runid]</code> - Filter the runs to those that have their id equal to the variable <code>runid</code>. Each run has a unique runid, so you can be sure that this query now contains one row.</li> <li><code>data.runs[runid].targuses</code> - Each run has multiple L1 single spectra associated with it and each of those spectra have a <code>targuse</code> attribute. Therefore, each run has multiple <code>targuse</code> attributes, therefore you must write <code>targuses</code>. </li> <li><code>data.runs[runid].targuses == 'S'</code> - Make a boolean mask for where the targuse flag for each spectrum belonging to this run is set to <code>'S'</code> (this refers to \"sky\").</li> <li><code>nsky = sum(data.runs[runid].targuses == 'S')</code> - Sum the entire boolean mask, thereby counting the number of sky fibres placed in this run.  The python function <code>sum</code> was overwritten with a <code>weaveio</code> version when we did our imports. <code>sum</code> is now compatible with <code>weaveio</code> but can also be used normally. </li> <li><code>nsky()</code> - Up til now, we have been building a query, much like we would write SQL, but nothing has executed on the database yet.  To run our query and fetch the result, we call it using the parentheses <code>()</code>.</li> </ol>"},{"location":"quickstart-by-example/#1b-i-want-to-see-how-many-sky-targets-each-run-has","title":"1b. I want to see how many sky targets each run has","text":"<p><pre><code>from weaveio import *\ndata = Data()\nnsky = sum(data.runs.targuses == 'S', wrt=data.runs)  # sum the number of sky targets with respect to their runs\nprint(nsky())\n</code></pre> output: <code>[100 299 299 100 100 200 160 ...]</code></p> <p>This query is very similar to the previous one except that we are summing over the fibres of each run, not just 1 run as before. The difference here is that we have missed out <code>data.runs[runid]</code> which means that our query references all <code>runs</code> in the database at once.</p> <ol> <li><code>from weaveio import *; data = Data()</code> - Import all the necessary <code>weaveio</code> functions and start the default lofar database link.</li> <li><code>data.runs</code> - Get all runs.</li> <li><code>data.runs.targuses == 'S</code> - Access all <code>targuse</code> attributes belonging to each run. Read this statement as \"for each run in data, for each targuse in run, do <code>==S</code>.</li> <li><code>nsky = sum(data.runs.targuses == 'S', wrt=data.runs)</code> - This time sum our boolean mask with respect to (<code>wrt</code>) <code>data.runs</code>.  This means each row in the resultant query, <code>nsky</code>, will refer to each row in <code>data.runs</code>. I.E. There is now a query row per run, whereas in the previous example there was only one row.</li> </ol>"},{"location":"quickstart-by-example/#1c-put-the-above-result-into-a-table-where-i-can-see-the-runid","title":"1c. Put the above result into a table where I can see the runid","text":"<p><pre><code>from weaveio import *\ndata = Data()\nnsky = sum(data.runs.targuses == 'S', wrt=data.runs)  # sum the number of skytargets with respect to their runs\nquery_table = data.runs[['id', nsky]]  # design a table by using the square brackets\nconcrete_table = query_table()  # make it \"real\" by executing the query\nprint(concrete_table)\nprint(type(concrete_table))\n</code></pre> output: <pre><code>   id   sum0\n------- ----\n1003453  100\n1003440  299\n...      ...\n&lt;class 'weaveio.readquery.results.Table'&gt;  # although this is an astropy table really\n</code></pre> Returning more than one attribute per row requires \"designing\" a table. To do this, we put a list of our required values in the square brackets <code>[['id', nsky]]</code>.  Any string referring to an attribute (e.g. <code>'id'</code>) can go here as well as any previously written query (e.g. <code>nsky</code>'). However, any items that you put in the square brackets must align with the object outside:</p> <p>For example: * <code>data.runs[['id', nsky]]</code> is valid because each <code>run</code> has an <code>id</code> and the query <code>nsky</code> is based on <code>data.runs</code> (i.e. each <code>run</code> has an <code>nsky</code> calculated for it).</p>"},{"location":"quickstart-by-example/#2-i-want-to-plot-all-single-sky-spectra-from-last-night-in-the-red-arm","title":"2. I want to plot all single sky spectra from last night in the red arm","text":"<p><pre><code>from weaveio import *\ndata = Data()\nyesterday = 57811  # state yesterday's date in MJD\nruns = data.runs\nis_red = runs.camera == 'red'\nis_yesterday = floor(runs.exposure.mjd) == yesterday  # round down to an integer, which is the day\nruns = runs[is_red &amp; is_yesterday]  # filter the runs to red ones that were taken yesterday  \nspectra = runs.l1single_spectra  # get all the spectra per run\nsky_spectra = spectra[spectra.targuse == 'S']  # filter to the spectra which are sky \ntable = sky_spectra[['wvl', 'flux']]  # design a table of wavelength and flux\nimport matplotlib.pyplot as plt\n# this may take a while to plot, there is a lot of data\nfor row in table:  # you can iterate over a query with `for` as well as requesting the whole thing with `()` \nplt.plot(row.wvl, row.flux, 'k-', alpha=0.4)  # standard matplotlib line plot \nplt.savefig('sky_spectra.png')\n</code></pre> output:</p> <p></p> <p>The only new thing in this query is <code>for row in table</code>. This implicitly calls the table (<code>table()</code>) and downloads one row at a time.  You will want to do this when the resulting query will be large. By using this \"iterator\" pattern, you can avoid loading it all into memory at once.</p>"},{"location":"quickstart-by-example/#3-i-want-to-plot-the-h-alpha-flux-vs-l2-redshift-distribution-from-all-wl-or-w-qso-spectra-that-were-observed-from-all-obs-observed-in-the-past-month-use-the-stacked-data","title":"3. I want to plot the H-alpha flux vs. L2 redshift distribution from all WL or W-QSO spectra that were observed from all OBs observed in the past month. Use the stacked data","text":"<pre><code>import matplotlib.pyplot as plt\ndata = Data()\nl2s = data.l2stacks\nl2s = l2s[(l2s.ob.mjd &gt;= 57780) &amp; any(l2s.fibre_target.surveys == '/WL.*/', wrt=l2s.fibre_target)]\nl2s = l2s[l2s['ha_6562.80_flux'] &gt; 0]\ntable = l2s[['ha_6562.80_flux', 'z']]()\nplt.scatter(table['z'], table['ha_6562.80_flux'], s=1)\nplt.yscale('log')\nplt.savefig('ha-z.png') \n</code></pre> <p>Let's break down this query:</p> <ol> <li><code>l2s = data.l2stacks</code> gets all l2stack products in the database. These are the data products which contain joined spectra and template fits.</li> <li><code>l2s.fibre_target.surveys == '/WL.*/'</code> - This creates a boolean mask matching the survey name to 'WL.*' with regex. You can activate regex by using <code>/</code> at the start and end of a string.</li> <li><code>l2s = l2s[(l2s.ob.mjd &gt;= 57780) &amp; any(l2s.fibre_target.surveys == '/WL.*/', wrt=l2s.fibre_target)]</code> - This filters to l2 products whose L1 observations were taken after 57780 and survey names containing \"WL\"</li> <li><code>l2s = l2s[l2s['ha_6562.80_flux'] &gt; 0]</code> - Then we further filter the l2 products by required an halpha flux greater than 0 (fit by Gandalf).</li> <li><code>l2s[['ha_6562.80_flux', 'z']]</code> - This designs a table with the halpha flux (from gandalf) and the redshift (from redrock)</li> </ol>"},{"location":"quickstart-by-example/#4a-join-on-a-3rd-party-catalogue","title":"4a. Join on a 3rd party catalogue","text":"<p>Given a catalogue of weave cnames, find those objects in the database and return the calendar dates on which those matched objects were observed, and the number of WEAVE visits to each CNAME (there could be more than one)</p> <p>To do this we need to use <code>join</code> which is imported from <code>weaveio</code>.  <code>join</code> takes at least 3 arguments: the first is the table to join on, the second is the column name in that table, and the third is the object in <code>weaveio</code> to join to. You may also specify a <code>join_query</code> which is another <code>weaveio</code> query that results in the attribute to join to. If this is not specified, then it is assumed that the attribute should be the same as the column name in the table. <pre><code>def join(table: Table, index_column: str,\nobject_query: ObjectQuery, join_query: Union[AttributeQuery, str] = None,\njoin_type: str = 'left') -&gt; Tuple[TableVariableQuery, ObjectQuery]:\n...\n</code></pre> The output of <code>join</code> is the input table converted to a <code>weaveio</code> variable and a reduced version of the input <code>object_query</code>. The output table variable should now be treated as rows.</p> <p><pre><code>from astropy.table import Table\nfrom weaveio import *\nimport weaveio\nfname = Path(weaveio.__file__).parents[0] / 'tests/my_table.ascii'\ndata = Data()\ntable = Table.read(fname, format='ascii')\nrows, targets = join(table, 'cname', data.weave_targets)\nmjds = targets.exposures.mjd  # get the mjd of the plate exposures for each target\nq = targets['cname', rows['modelMag_i'], {'mjds': mjds, 'nobservations': count(mjds, wrt=targets)}]\nprint(q())\n</code></pre> output: <pre><code>       cname         modelMag_i          mjds [15]           nobservations\n-------------------- ---------- ---------------------------- -------------\nWVE_10461805+5755400   20.20535 57809.109711 .. 57811.075961            15\nWVE_10521675+5814292    21.2665 57809.109711 .. 57811.075961            15\nWVE_10521675+5814292    21.2665 57809.109711 .. 57811.075961            15\nWVE_02175674-0451074   21.38155             57640.1764 .. --             6\nWVE_02174727-0459587   21.81214             57640.1764 .. --             6\nWVE_02175411-0504122   22.28189             57640.1764 .. --             6\nWVE_02175687-0512209   21.79577             57640.1764 .. --             6\nWVE_02174991-0454427   21.65417             57640.1764 .. --             6\nWVE_02175370-0448267   19.63735             57640.1764 .. --             6\nWVE_02174862-0457336     22.181             57640.1764 .. --             6\nWVE_02175320-0508011   20.16733             57640.1764 .. --             6\n</code></pre> Breaking down this query: 1. <code>table = Table.read('weaveio/tests/my_table.ascii', format='ascii')</code> - This reads in a custom table from the file <code>my_table.ascii</code>. One of the column names is <code>cname</code>. 2. <code>rows, targets = join(table, 'cname', data.weave_targets)</code> - This joins the <code>cname</code> column of the table to the <code>cname</code> attribute of the weave targets catalogue. <code>targets</code> will refer to all <code>weave_targets</code> that were matched by the <code>cname</code> column and <code>rows</code> will refer to the rows of the table. 3. <code>mjds = targets.exposures.mjd</code> - This gets the mjd of the plate exposures for each target (there may be more than 1) and each exposure will have 2 <code>l1single_spectra</code> (one for each arm), although we don't worry about that yet.  4. <code>q = targets['cname', rows['modelMag_i'], {'mjds': mjds, 'nobservations': count(mjds, wrt=targets)}]</code> - This creates a table using the 'modelMag_i' found in the fits file table. This can be done because we joined it earlier. Here we are also renaming columns to more human readable names using a dictionary. </p>"},{"location":"quickstart-by-example/#ragged-arrays","title":"Ragged arrays","text":"<p>The mjd result column is \"ragged\" array since there may be more than 1 exposure per target and that is not constant for each target. So that the user can aggregate easily we convert the mjd result column to a regular array and mask it.</p>"},{"location":"quickstart-by-example/#4b-plot-sdss-modelmag_i-from-the-fits-file-against-mean-flux-between-400-450nm","title":"4b. Plot sdss modelMag_i from the fits file against mean flux between 400-450nm","text":"<p>Continuing from 4a, we first traverse to the <code>l1single_spectra</code> and fetch their wavelengths and fluxes. Then we plot the modelMag_i from the fits file against the mean flux between 400-450nm.</p> <p><pre><code>import matplotlib.pyplot as plt\nq = targets.l1single_spectra[['cname', rows['modelMag_g'], 'wvl', 'flux', 'sensfunc']]\ntable = q()\nmean_fluxes = []\nfor row in table:\nfilt = (row['wvl'] &gt; 4000) &amp; (row['wvl'] &lt; 4500)  # angstroms\nmean_fluxes.append(mean(row['flux'][filt]))\ntable['mean_flux'] = mean_fluxes\nprint(table['mean_flux'])\nplt.scatter(table['modelMag_g'], -2.5 * np.log10(table['mean_flux']))\nplt.show()\n</code></pre> output: <pre><code>      mean_flux      \n---------------------\n   1.6613570457103553\n   1.8225295509082666\n   1.6668027617324288\n                   --\n   1.8113559953805027\n                   --\n    1.685038564203977\n                  ...\n                   --\n -0.07946323931008473\n                   --\n-0.012973852190988072\n -0.13294200506014725\n                   --\n                   --\nLength = 90 rows\n</code></pre> </p>"},{"location":"quickstart-by-example/#5-for-each-ob-at-a-time-retrieve-all-the-stacked-red-arm-sky-spectra-and-the-single-spectra-that-went-into-making-those-stacked-spectra","title":"5. For each OB at a time, retrieve all the stacked red-arm sky spectra and the single spectra that went into making those stacked spectra","text":"<p><pre><code>from weaveio import *\ndata = Data()\nobs = split(data.obs)  # mark the fact that you want have one table per OB thereby \"splitting\" the query in to multiple queries\nstacks = obs.l1stack_spectra[(obs.l1stack_spectra.targuse == 'S') &amp; (obs.l1stack_spectra.camera == 'red')]\nsingles = stacks.l1single_spectra\nsingles_table =  singles[['flux', 'ivar']]\nquery = stacks[['ob.id', {'stack_flux': 'flux', 'stack_ivar': 'ivar'}, 'wvl', {'single_': singles_table}]]\nfor index, ob_query in query:\nprint(f\"stacks and singles for OB #{index}:\")\nprint(ob_query())\n</code></pre> output: <pre><code>stacks and singles for OB #3133:\nob.id stack_flux [15289] ... single_flux [3,15289] single_ivar [3,15289]\n----- ------------------ ... --------------------- ---------------------\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n 3133         0.0 .. 0.0 ...            0.0 .. 0.0            0.0 .. 0.0\n</code></pre> Breaking down this query:</p> <p>There are two new concepts in this example: query splitting and adding tables together.</p> <ol> <li>Splitting occurs with <code>obs = split(data.obs)</code>.  Nothing special happens here except that we have now marked that any query that follows from <code>obs</code> will yield more than one table. Each table will have a different <code>ob.id</code> value</li> <li>We continue our query as normal</li> <li><code>query = stacks[['ob.id', {'stack_flux': 'flux', 'stack_ivar': 'ivar'}, 'wvl', {'single_': singles_table}]]</code> - Here we have now added the <code>singles_table</code> into a new table we are constructing. This is equivalent to <code>query = stacks[['ob.id', {'stack_flux': 'flux', 'stack_ivar': 'ivar'}, 'wvl', {'single_flux': singles['flux'], 'single_ivar': singles['ivar']}]]</code>.  When renaming the additional table (with <code>{'single_': ...}</code>) we are added a prefix onto each of the new columns.</li> <li><code>for index, ob_query in query:</code> - <code>query</code> is now split query, so when we iterate over it we get one table for each ob.id value.  It also returns an index, which in this case is just the <code>ob.id</code> value. <code>ob_query</code> is now identical to the original <code>query</code> except that is will only return results for one OB.</li> <li><code>ob_query()</code> - Execute the query only for the current OB (the one with <code>ob.id == index</code>).</li> </ol> <p><code>split</code> is the equivalent function to <code>group_by</code> in pandas or astropy. However, you must perform a <code>split</code> before querying whereas in a pandas/astropy <code>group_by</code> it is done after the fact.</p> <p>Also, it is important to note that the <code>single_flux</code> and <code>single_ivar</code> columns are 2 dimensional since there are 3 single spectra per stack spectrum.  So you get all 3 at once, per row of the query.</p>"},{"location":"splitting/","title":"Splitting queries","text":"<p><code>weaveio</code> is more than just a query language, it is a system also to perform actions on its own queries.</p> <p>The <code>split</code> function creates a separate sub-query for each row that would be returned.</p> <p>For example, <code>split(data.obs)</code> will create around 30 sub-queries (one for each OB in the database). You can continue the query as you normally would but this time you are acting on each sub-query. It's like a for loop over all OBs.</p> <p>You probably want to iterate over a split query rather than call it directly because that defeats the point of a split query. Iteration works slightly differently as it yields and index (in this case the OB id) as well as the sub-query.</p> <pre><code>for index, subquery in split(data.obs):\n</code></pre> <p>A full example is given here where you want to get all the L1SingleSpectra per ob, in batches per ob: <pre><code>from weaveio import *\ndata = Data()\nobs = split(data.obs)  # mark the fact that you want have one table per OB thereby \"splitting\" the query in to multiple queries\nsingles = obs.l1single_spectra\nquery =  singles[['flux', 'ivar']]\nfor index, ob_query in query:\nprint(f\"stacks and singles for OB #{index}:\")\nprint(ob_query())\n</code></pre></p>"},{"location":"stacking/","title":"Stacking, aligning, and joining","text":""},{"location":"stacking/#stacking-tables-together","title":"Stacking tables together","text":"<p>You can stack related tables together, which is much like an SQL merge operation.</p> <p>For example, let's construct two tables of <code>run.id</code> and number of spectra for every red run and every blue run.</p> <pre><code>exps = data.exposures\nreds = exps.runs[exps.runs.colour == 'red']\nblues = exps.runs[exps.runs.colour == 'blue']\nred_table = reds[['id', count(reds.l1single_spectra, wrt=reds)]]\nblue_table = blues[['id', count(blues.l1single_spectra, wrt=blues)]]\n</code></pre> <p>We can execute each of these tables to see their results: <pre><code>&gt;&gt;&gt; red_table()\nid   count\n------- -----\n1002213   960\n1002215   960\n...\n&gt;&gt;&gt; blue_table()\nid   count\n------- -----\n1002214   960\n1002216   960\n...\n</code></pre></p> <p>Now if we wanted a table where each row refers to an exposure and contains 4 columns: red id, red count, blue id, and blue count,  we would stack the <code>red_table</code> and <code>blue_table</code> like so:</p> <pre><code>t = exps[[red_table, blue_table]]\n</code></pre> <p>Failure</p> <p>this next bit doesn't work</p> <p><pre><code>&gt;&gt;&gt; t()\nid0      count0   id1     count1\n---      ------   ---     ------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre> Or you could give more helpful names by specifying a prefix in a dictionary:</p> <pre><code>t = exps[[{'red_': red_table, 'blue_': blue_table}]]\n</code></pre> <pre><code>&gt;&gt;&gt; t()\nred_id   red_count   blue_id     blue_count\n------   ---------   -------     ----------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre>"},{"location":"stacking/#aligning-queries","title":"Aligning queries","text":"<p>In the previous example, there was a bit of duplication of effort when designing the tables for the red and blue arms. You can avoid this by using <code>align</code>:</p> <p><pre><code>red_and_blue = align(reds, blues) \n</code></pre> After using <code>align</code> you can then continue to construct your query just as you would have done except now you don't have to do it for the red and blue arms individually: <pre><code>aligned_t = red_and_blue[['id', count(red_and_blue.l1single_spectra, wrt=red_and_blue)]]\n</code></pre> If we execute this query we get the same result as above: <pre><code>&gt;&gt;&gt; aligned_t()\n&gt;&gt;&gt; t()\nid0      count0   id1     count1\n---      ------   ---     ------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre></p> <p>You can also get the helpful names back by specifying the prefix in the <code>align</code> function: <pre><code>red_and_blue = align(red=reds, blue=blues)\n</code></pre></p> <p>After aligning two or more query objects, you can perform any operation on the aligned query that you would perform on a normal query. Behind the scenes, your operation is performed for each query in the aligned query. </p> <p>Failure</p> <p>You may only <code>align</code> queries that share a common ancestor. In the above case, that common ancestor was <code>exps (=data.exposures)</code>. If you try to <code>align</code> on queries which are not related in this way, the query will fail: <pre><code>&gt;&gt;&gt; align(data.runs, data.exposures)\nValueError: All queries must be from the same parent Data object\n</code></pre></p>"},{"location":"stacking/#joining","title":"Joining","text":"<p>Sometimes you will want to query the database using some data that you have locally available.  For instance, you may have a list of redshifts fit by your own method, and you want to find the spectra for which WEAVE and your method disagree.</p> <p>Joining allows you to upload this personal table to the database temporarily and only accessible to you. The added data is only available to the uploader whilst the query is being executed and is never committed to the database.</p> <p>Joining works by finding an object in the database that you can match against. You can then traverse and query as normal with each row in your joined table being treated as singular with respect to that object.</p> <p>For example, we can join a table where each row corresponds to a weave_target cname <pre><code>table, weave_targets = join(table, 'cname', data.weave_targets.cname)\n</code></pre> <code>weave_targets</code> is the subset of <code>data.weave_targets</code> that is matched to the table <code>table</code> is the entire table</p> <p>We can implement the above redshift example as detailed below: <pre><code>my_redshifts = Table.read('my/fancy/redshifts.fit')  # has columns: weave_cname, l2_filename, my_redshift   \ntable, l2 = join(my_redshifts, ['weave_cname', 'l2_filename'], data.l2s[['cname', 'fname']], 'table')\n</code></pre></p>"},{"location":"syntax-summary/","title":"Syntax summary","text":"<ul> <li>access objects: <code>&lt;(object|database)&gt;.&lt;object&gt;...</code>: <code>data.l1single_spectra.ob</code></li> <li>access attributes: <code>&lt;object&gt;.&lt;attribute&gt;</code> or <code>&lt;object&gt;['attribute']</code>: <code>spectrum.snr</code> or <code>spectrum['snr']</code></li> <li>identifying by id: <code>&lt;object[plural]&gt;[&lt;id[str|int|float]&gt;]</code>: <code>data.obs[3443]</code></li> <li>identifying by ids: <code>&lt;object[plural]&gt;[&lt;id[str|int|float]&gt;, ...]</code>: <code>data.obs[3443, 4421]</code></li> <li>filtering by mask: <code>&lt;object|attribute&gt;[&lt;attribute[bool]&gt;]</code>: <code>spectra[spectra.snr &gt; 10]</code></li> </ul>"},{"location":"tables/","title":"Designing result tables","text":""},{"location":"tables/#using-strings-as-columns","title":"Using strings as columns","text":"<p>Tables are build on top of objects in weaveio.  To design a table in your query, you use the double square brackets: <pre><code>table = spectra[['nspec', 'snr']]\n</code></pre> In this example, <code>spectra</code> is the inciting object and <code>'nspec'</code> and <code>'snr'</code> are the attribute names with which to make columns.</p> <p>When the above query is executed, an astropy table is returned. <pre><code>&gt;&gt;&gt; table()\nnspec      snr\nint      float\n-----     -----\n0       2.582\n1       0.124\n</code></pre> Note that only the attributes that are requested are included in the table output. Any other attributes including unique ids will not be returned unless specified. And just like before, you may not return objects themselves only their attributes:</p> <p>Failure</p> <pre><code>&gt;&gt;&gt; spectra[['nspec', 'snr', 'survey_target']]\nSyntaxError: SurveyTarget cannot be returned/identified since it doesn't define any unique idname. \nIf you want to return all singular data for SurveyTarget use ...['*']\n</code></pre>"},{"location":"tables/#using-other-queries-as-columns","title":"Using other queries as columns","text":"<p>Any attribute name in the square brackets is assumed to relate to the proceeding object. Indeed, you can be explicit:  <pre><code>spectra[[spectra.nspec, spectra.snr]]\n</code></pre> This is an example of using a query (<code>spectra.nspec</code> and <code>spectra.snr</code>) as a column.</p> <p>You can specify any query as a column as long as it has the inciting object as a parent. This means that a query inside the square bracket must reference the inciting object at a point in its history.</p> <p>To illustrate this point, consider the following example where we get a list of <code>spectra</code> for each <code>exposure</code> in the database. <pre><code>specs = data.exposures.l1single_spectra\nsignificant = specs.snr &gt; 5\n</code></pre></p> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', 'snr']]()\nnspec        snr        \n----- ------------------\n247 111.34782409667969\n177 47.183815002441406\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr]]()\nnspec        snr        \n----- ------------------\n247 111.34782409667969\n177 47.183815002441406\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr&gt;5]]()\nnspec  &gt;  \n----- ----\n247 True\n177 True\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', significant]]()\nnspec  &gt;  \n----- ----\n247 True\n177 True\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.exposures.mjd]]()\nnspec     mjd     \n----- ------------\n247 57639.865255\n177 57639.865255\n</code></pre> <p>Warning</p> <p><pre><code>&gt;&gt;&gt; specs[['nspec', data.exposures.mjd]]()\nnspec     mjd[523]\n----- ------------\n247 [57639.865255, ...]\n248 [57639.865255, ...]\n</code></pre> This query actually returns the same list of all exposure mjd values in the database for each spectrum - a huge duplication of effort.</p>"},{"location":"tables/#renaming-columns","title":"Renaming columns","text":"<p>Sometimes the column name that is assigned to a column is less than helpful: <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr &gt; 3, specs.snr &gt; 4]]()\nnspec  &gt;0   &gt;1 \n----- ---- ----\n247 True True\n177 True True\n</code></pre></p> <p>If we want to override the given name we can use a dictionary: <pre><code>&gt;&gt;&gt; specs[['nspec', {'snr &gt; 3': specs.snr &gt; 3, 'snr &gt; 4': specs.snr &gt; 4}]]()\nnspec snr &gt; 3 snr &gt; 4\n----- ------- -------\n247    True    True\n177    True    True\n</code></pre></p>"}]}