{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"weaveio","text":"<p>This is documentation for the use, maintenance, and development of <code>weaveio</code>, the data product database tool in use by the WEAVE-LOFAR survey.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>The purpose of <code>weaveio</code> is to facilitate easy querying of complex data spread over multiple file types. </p> <p>Specifically, it was designed to allow the user write complex queries over the L1 and L2 data structures output by the WEAVE CPS and APS.  The data consists of weather measurements, spectra (both 1D and 2D), previous survey input target observations, redshifts, emission lines, velocity dispersion etc.</p> <p>All of this information is highly hierarchical. I.e. a spectrum requires a target, which has an {ra,dec} coordinate.  The spectrum also has numerous emission line fits and redshifts which have been inferred from the spectrum. You could write this as <code>(target {ra, dec})--&gt;(spectrum)--&gt;(fit {redshift})--&gt;(emission_line)</code>.  This kind of structure lends itself to be written in an object orientated way and queried as such.</p> <p>Essentially, all of <code>weaveio</code> is designed to turn this:</p> <pre><code>from astropy.io import fits\nfrom astropy.table import Table\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\ntarget_name = 'xxxxx'\nexposure_mjd = 57639\nwvl = []\nflux = []\nfor file in os.listdir('opr3'):\nif 'single' in file:\nhdus = fits.open(file)\nif floor(hdus[0].header['MJD']) == exposure_mjd:\nt = Table(hdus['FIBTABLE'].data)\nfilt = t['TARGNAME'] == target_name\nif sum(filt):\nheader = hdulist[1].header\nincrement, zeropoint = header['cd1_1'], header['crval1'] \nsize = header['naxis1']\nwvl.append(np.arange(0, size) * increment) + zeropoint)\nflux.append(hdulist[1].data[filt])\nplt.plot(wvl, flux)\nplt.title('All L1 single spectra of {target_name} on day {exposure_mjd}')\n</code></pre> <p>Into this:</p> <pre><code>import matplotlib.pyplot as plt\nfrom weaveio import *\ndb = Data('opr3')\nspectra = db.survey_targets[target_name].l1single_spectra\nresult = spectra[floor(spectra.exposure.mjd) == exposure_mjd][['wvl', 'flux']]()\nplt.plot(result.wvl, result.flux)\nplt.title('All L1 single spectra of {target_name} on day {exposure_mjd}')         \n</code></pre>"},{"location":"building-queries/","title":"Identifying, filtering and aggregating","text":""},{"location":"building-queries/#finding-objects-by-their-unique-identifiers","title":"Finding objects by their unique identifiers","text":"<p>If an object defines an idname in its class definition, you can find it in a query by </p> <p>Once you've traversed to an attribute, you can filter and aggregate.</p>"},{"location":"building-queries/#_1","title":"Building queries","text":"<p>For example: <pre><code>database.cats.owner.age &gt; database.cats.age\n</code></pre> This query is a boolean structure the same shape as <code>database.cats</code> (and also <code>database.cats.owner</code> since a cat only has one owner).</p>"},{"location":"database-connector/","title":"The database connector","text":"<p>Every query in weaveio starts with a database connector - <code>Data</code>. The <code>Data</code> class represents all the information in the database and contains the backend for connecting to it.</p> <p>When designing the database schema, you inherit from the <code>Data</code> class.  However, for convenience, when you import <code>Data</code> from weaveio, the opr3 database connector is imported, not the base <code>Data</code> class.</p> <p><code>Data</code> has the following signature: <pre><code>Data(rootdir: Union[Path, str] = None, host: str = None, port: int = None, \ndbname: str = None, password: str = None, user: str = None, verbose=False)\n</code></pre> Most of these arguments will have default values which have been specified (for example in the opr3 database connector class). However, you can override any of them if necessary and <code>user</code> and <code>password</code> are required arguments. You can also specify environment variables to avoid pushing passwords to github. These are: <pre><code>WEAVEIO_DB\nWEAVEIO_HOST\nWEAVEIO_PORT\nWEAVEIO_PASSWORD\nWEAVEIO_USER\nWEAVEIO_ROOTDIR\n</code></pre></p>"},{"location":"objects/","title":"Objects and their attributes in weaveio with cats","text":"<p>Info</p> <p>This section will talk about how to access objects and their attributes in weaveio. It will talk about schema and relationships but it will not describe how to build a schema or write data to the database. This is done in the writing section.</p> <p>An object in weaveio is a container for attributes. For example, a <code>Cat</code> object has a <code>tail_length</code> attribute.  A <code>Cat</code> object may also have an <code>Owner</code> attribute (note that the <code>Owner</code> is itself an object that has its own attributes).</p> <p>Let's suppose that the database has this structure:</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> This structure is pronounced \"An Owner has a Cat which has a Toy\".</p> <p>In weaveio you always traverse to objects from another object following these arrows.</p> <ol> <li>For each cat get its owner: <code>cat.owner</code></li> <li>For each cat's owner get its name and return them all: <code>cat.owner.name()</code></li> </ol> <p>You can read the dots as \"For each cat get its owner, for each owner get its name\".</p> <p>You cannot return an object in weaveio, only attributes of objects.</p> <p>Success</p> <pre><code>&gt;&gt;&gt; database.cats.owner['name']()\n['Andrea', 'Mike', 'Humphrey']\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; database.cats.owner()\nSyntaxError: Owner cannot be returned/identified since it doesn't define any unique idname. \nIf you want to return all singular data for Owner use ...['*']\n</code></pre>"},{"location":"objects/#attribute-access","title":"Attribute access","text":"<p>In weaveio you can access attributes using either the square brackets <code>object['attribute']</code> or the dot syntax <code>object.attribute</code>.  There is no difference between them.  The only reason that you would use <code>object['attribute']</code> over <code>object.attribute</code> is when requesting more than one attribute at once (see tables).</p> <p>Weaveio is designed such that, in the relationship hierarchy above, all linked objects/attributes are accessible.</p> <p>So <code>owner.cat.toy</code> is the same as <code>owner.toy</code>:</p> <p>Success</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; owner.cat.toy() == owner.toy()\nTrue\n</code></pre></p> <p>Furthermore, <code>owner.squeakiness</code> is the same as <code>owner.toy.squeakiness</code>:</p> <p>Success</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; owner.toy.squeakiness() == owner.squeakiness()\nTrue\n</code></pre></p> <p>However, <code>cat.bike</code> is not valid because the cat has no direct access to the bike.  You must explicitly traverse to Owner first:</p> <p>Warning</p> <p><pre><code>graph LR\n  Owner --&gt; Cat;\n  Owner --&gt; Bike;\n  Cat --&gt; Toy;  </code></pre> <pre><code>&gt;&gt;&gt; cat.bike\nAmbiguousPathError\n&gt;&gt;&gt; cat.owner.bike    \n</code></pre></p>"},{"location":"objects/#a-note-on-pluralisations","title":"A note on pluralisations","text":"<p>If an object has more than one linked object then you must use the plural form of the object. </p> <p>Let's consider an altered schema where there are multiple relationships between each object type. <pre><code>graph LR\n  Owner --\"many\"--&gt; Cat;\n  Cat --\"one\"--&gt; Owner;\n  Cat --\"many\"--&gt; Toy;\n  Toy--\"one\"--&gt;Cat;</code></pre></p> <p>Success</p> <pre><code>&gt;&gt;&gt; cat.toys.name()\n['mouse', 'ribbon', 'bell']\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; cat.toy.name()\nKeyError: A Cat has more than one Toy. Use the plural \"toys\".\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; toy.cat.name()\nFelix\n</code></pre>"},{"location":"objects/#cardinalty","title":"Cardinalty","text":"<p>If we interpret the dot syntax as \"for each\" as detailed above, then this implies an increase in the number of results with each level. For example, in the above example each cat has one owner and an owner can only own one cat.  Let's now say that Mike owns both Felix and Whiskers.</p> <p>The list of owners is still the same: <pre><code>&gt;&gt;&gt; database.owners['name']()\n['Andrea', 'Mike', 'Humphrey']\n</code></pre></p> <p>But now if we ask for the owner of each cat: <pre><code>&gt;&gt;&gt; database.cats.owner['name']()\n['Andrea', 'Mike', 'Humphrey', 'Mike']\n</code></pre> We can now see that Mike appears twice.</p> <p>Warning</p> <p>Things can quickly get out of control in a large interconnected database when traversing the same relationship repeatedly:  <pre><code>&gt;&gt;&gt; database.cats.owner.cats.owner['name']()\n['Andrea', 'Mike', 'Mike', 'Humphrey', 'Mike', 'Mike']\n</code></pre> Things duplicate because we've asked for the owner of each cat and then the owner of each of those cats.</p>"},{"location":"objects/#types-of-object","title":"Types of object","text":"<p>Objects have types and you can query different types just as you would normally.  In weaveio all objects inherit from <code>Hierarchy</code>:</p> <p><pre><code>&gt;&gt;&gt; database.hierarchies['name']()\n['Andrea', 'Mike', 'Humphrey', 'Felix', 'Whiskers', 'Smudge', 'mouse', 'ribbon', 'bell']\n</code></pre> If <code>Cat</code> is defined as a type of <code>Animal</code> then <code>database.animals['name']()</code> will return all the names of all the Cats:</p> <p><pre><code>&gt;&gt;&gt; database.animals['name']()\n['Smudge', 'Felix', 'Whiskers']\n</code></pre> If Owner was defined as an animal then this query would also fetch the names of the owners too.</p>"},{"location":"objects/#attribute-manipulation","title":"Attribute manipulation","text":"<p>You may perform arithmetic on attributes of objects in the query.  All standard operators are supported: <code>&lt;, &gt;, &lt;=,&gt;=, +, -, /, *, **, &amp;, |, ~</code> and they are type sensitive.</p> <p>For example:</p> <p>Success</p> <pre><code>&gt;&gt;&gt; old_cat_filter = cat.age &gt; cat.owner.age &gt; 10\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; cat.name &gt; 10 \nTypeError: &gt; expected a number, got string\n</code></pre> <p><code>weaveio</code> comes with its own versions of common scalar functions <code>log, exp, log10, sqrt, sign, floor, ceil, isnan</code>, and aggergating functions <code>sum, any, all, mean, std, count, exists, max, min</code></p> <p>Warning</p> <p><code>weaveio</code> functions override the default python functions. i.e. <code>sum</code> is replaced by <code>weaveio.sum</code> when importing with <code>from weaveio import *</code>. <code>weaveio.sum</code> supports all the functionality of Python's <code>sum</code>when not confronted with a <code>weaveio</code> query. Otherwise, it will return another <code>weaveio</code> query. Since Python's <code>sum</code> cannot be used with <code>weaveio</code>, you are recommended to import using <code>from weaveio import *</code>.</p>"},{"location":"objects/#products","title":"Products","text":"<p><code>weaveio</code> supports accessing external data products which are not held in the database. The use case for this is if the attribute is too large and no benefit is gained by storing it in the database. For instance large numerical arrays should not be stored in database and should be marked as products when uploading.</p> <p>If an attribute is marked as a product, it cannot be manipulated like normal attributes.  All functions and operators will fail. However, you may still retrieve the data products in the same way as attributes:</p> <p>Success</p> <pre><code>&gt;&gt;&gt; database.spectra.flux()\n[np.array([...]), np.array([...]), ...]\n</code></pre> <p>Failure</p> <pre><code>&gt;&gt;&gt; snr = database.spectra.flux * sqrt(database.spectra.ivar)\nTypeError: `flux` is a product and cannot be manipulated in query, only retrieved.\n</code></pre>"},{"location":"quickstart-by-example/","title":"Quickstart by example","text":""},{"location":"stacking/","title":"Stacking, aligning, and joining","text":""},{"location":"stacking/#stacking-tables-together","title":"Stacking tables together","text":"<p>You can stack related tables together, which is much like an SQL merge operation.</p> <p>For example, let's construct two tables of <code>run.id</code> and number of spectra for every red run and every blue run.</p> <pre><code>exps = data.exposures\nreds = exps.runs[exps.runs.colour == 'red']\nblues = exps.runs[exps.runs.colour == 'blue']\nred_table = reds[['id', count(reds.l1single_spectra, wrt=reds)]]\nblue_table = blues[['id', count(blues.l1single_spectra, wrt=blues)]]\n</code></pre> <p>We can execute each of these tables to see their results: <pre><code>&gt;&gt;&gt; red_table()\nid   count\n------- -----\n1002213   960\n1002215   960\n...\n&gt;&gt;&gt; blue_table()\nid   count\n------- -----\n1002214   960\n1002216   960\n...\n</code></pre></p> <p>Now if we wanted a table where each row refers to an exposure and contains 4 columns: red id, red count, blue id, and blue count,  we would stack the <code>red_table</code> and <code>blue_table</code> like so:</p> <pre><code>t = exps[[red_table, blue_table]]\n</code></pre> <p>Failure</p> <p>this next bit doesn't work</p> <p><pre><code>&gt;&gt;&gt; t()\nid0      count0   id1     count1\n---      ------   ---     ------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre> Or you could give more helpful names by specifying a prefix in a dictionary:</p> <pre><code>t = exps[[{'red_': red_table, 'blue_': blue_table}]]\n</code></pre> <pre><code>&gt;&gt;&gt; t()\nred_id   red_count   blue_id     blue_count\n------   ---------   -------     ----------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre>"},{"location":"stacking/#aligning-queries","title":"Aligning queries","text":"<p>In the previous example, there was a bit of duplication of effort when designing the tables for the red and blue arms. You can avoid this by using <code>align</code>:</p> <p><pre><code>red_and_blue = align(reds, blues) \n</code></pre> After using <code>align</code> you can then continue to construct your query just as you would have done except now you don't have to do it for the red and blue arms individually: <pre><code>aligned_t = red_and_blue[['id', count(red_and_blue.l1single_spectra, wrt=red_and_blue)]]\n</code></pre> If we execute this query we get the same result as above: <pre><code>&gt;&gt;&gt; aligned_t()\n&gt;&gt;&gt; t()\nid0      count0   id1     count1\n---      ------   ---     ------\n1002213   960     1002214       960\n1002215   960     1002216       960\n...\n</code></pre></p> <p>You can also get the helpful names back by specifying the prefix in the <code>align</code> function: <pre><code>red_and_blue = align(red=reds, blue=blues)\n</code></pre></p> <p>After aligning two or more query objects, you can perform any operation on the aligned query that you would perform on a normal query. Behind the scenes, your operation is performed for each query in the aligned query. </p> <p>Failure</p> <p>You may only <code>align</code> queries that share a common ancestor. In the above case, that common ancestor was <code>exps (=data.exposures)</code>. If you try to <code>align</code> on queries which are not related in this way, the query will fail: <pre><code>&gt;&gt;&gt; align(data.runs, data.exposures)\nValueError: All queries must be from the same parent Data object\n</code></pre></p>"},{"location":"stacking/#joining","title":"Joining","text":"<p>Sometimes you will want to query the database using some data that you have locally available.  For instance, you may have a list of redshifts fit by your own method, and you want to find the spectra for which WEAVE and your method disagree.</p> <p>Joining allows you to upload this personal table to the database temporarily and only accessible to you. The added data is only available to the uploader whilst the query is being executed and is never committed to the database.</p> <p>Joining works by finding an object in the database that you can match against. You can then traverse and query as normal with each row in your joined table being treated as singular with respect to that object.</p> <p>For example, we can join a table where each row corresponds to a weave_target cname <pre><code>table, weave_targets = join(table, 'cname', data.weave_targets.cname)\n</code></pre> <code>weave_targets</code> is the subset of <code>data.weave_targets</code> that is matched to the table <code>table</code> is the entire table</p> <p>We can implement the above redshift example as detailed below: <pre><code>my_redshifts = Table.read('my/fancy/redshifts.fit')  # has columns: weave_cname, l2_filename, my_redshift   \ntable, l2 = join(my_redshifts, ['weave_cname', 'l2_filename'], data.l2s[['cname', 'fname']], 'table')\n</code></pre></p>"},{"location":"syntax-summary/","title":"Syntax summary","text":"<ul> <li>access objects: <code>&lt;(object|database)&gt;.&lt;object&gt;...</code>: <code>data.l1single_spectra.ob</code></li> <li>access attributes: <code>&lt;object&gt;.&lt;attribute&gt;</code> or <code>&lt;object&gt;['attribute']</code>: <code>spectrum.snr</code> or <code>spectrum['snr']</code></li> <li>identifying by id: <code>&lt;object[plural]&gt;[&lt;id[str|int|float]&gt;]</code>: <code>data.obs[3443]</code></li> <li>identifying by ids: <code>&lt;object[plural]&gt;[&lt;id[str|int|float]&gt;, ...]</code>: <code>data.obs[3443, 4421]</code></li> <li>filtering by mask: <code>&lt;object|attribute&gt;[&lt;attribute[bool]&gt;]</code>: <code>spectra[spectra.snr &gt; 10]</code></li> </ul>"},{"location":"tables/","title":"Designing result tables","text":""},{"location":"tables/#using-strings-as-columns","title":"Using strings as columns","text":"<p>Tables are build on top of objects in weaveio.  To design a table in your query, you use the double square brackets: <pre><code>table = spectra[['nspec', 'snr']]\n</code></pre> In this example, <code>spectra</code> is the inciting object and <code>'nspec'</code> and <code>'snr'</code> are the attribute names with which to make columns.</p> <p>When the above query is executed, an astropy table is returned. <pre><code>&gt;&gt;&gt; table()\nnspec      snr\nint      float\n-----     -----\n0       2.582\n1       0.124\n</code></pre> Note that only the attributes that are requested are included in the table output. Any other attributes including unique ids will not be returned unless specified. And just like before, you may not return objects themselves only their attributes:</p> <p>Failure</p> <pre><code>&gt;&gt;&gt; spectra[['nspec', 'snr', 'survey_target']]\nSyntaxError: SurveyTarget cannot be returned/identified since it doesn't define any unique idname. \nIf you want to return all singular data for SurveyTarget use ...['*']\n</code></pre>"},{"location":"tables/#using-other-queries-as-columns","title":"Using other queries as columns","text":"<p>Any attribute name in the square brackets is assumed to relate to the proceeding object. Indeed, you can be explicit:  <pre><code>spectra[[spectra.nspec, spectra.snr]]\n</code></pre> This is an example of using a query (<code>spectra.nspec</code> and <code>spectra.snr</code>) as a column.</p> <p>You can specify any query as a column as long as it has the inciting object as a parent. This means that a query inside the square bracket must reference the inciting object at a point in its history.</p> <p>To illustrate this point, consider the following example where we get a list of <code>spectra</code> for each <code>exposure</code> in the database. <pre><code>specs = data.exposures.l1single_spectra\nsignificant = specs.snr &gt; 5\n</code></pre></p> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', 'snr']]()\nnspec        snr        \n----- ------------------\n247 111.34782409667969\n177 47.183815002441406\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr]]()\nnspec        snr        \n----- ------------------\n247 111.34782409667969\n177 47.183815002441406\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr&gt;5]]()\nnspec  &gt;  \n----- ----\n247 True\n177 True\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', significant]]()\nnspec  &gt;  \n----- ----\n247 True\n177 True\n</code></pre> <p>Success</p> <pre><code>&gt;&gt;&gt; specs[['nspec', specs.exposures.mjd]]()\nnspec     mjd     \n----- ------------\n247 57639.865255\n177 57639.865255\n</code></pre> <p>Warning</p> <p><pre><code>&gt;&gt;&gt; specs[['nspec', data.exposures.mjd]]()\nnspec     mjd[523]\n----- ------------\n247 [57639.865255, ...]\n248 [57639.865255, ...]\n</code></pre> This query actually returns the same list of all exposure mjd values in the database for each spectrum - a huge duplication of effort.</p>"},{"location":"tables/#renaming-columns","title":"Renaming columns","text":"<p>Sometimes the column name that is assigned to a column is less than helpful: <pre><code>&gt;&gt;&gt; specs[['nspec', specs.snr &gt; 3, specs.snr &gt; 4]]()\nnspec  &gt;0   &gt;1 \n----- ---- ----\n247 True True\n177 True True\n</code></pre></p> <p>If we want to override the given name we can use a dictionary: <pre><code>&gt;&gt;&gt; specs[['nspec', {'snr &gt; 3': specs.snr &gt; 3, 'snr &gt; 4': specs.snr &gt; 4}]]()\nnspec snr &gt; 3 snr &gt; 4\n----- ------- -------\n247    True    True\n177    True    True\n</code></pre></p>"}]}